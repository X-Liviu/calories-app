# Día 12 - Desarrollo de la aplicación Fullstack (React, Node.js y Express)

## Miércoles 10 de septiembre de 2025

## Lo conseguido hoy:

### Backend

- Cambiado el modelo **Meal** para guardar si es una cheat meal.
- Agregado el PUT para modificar **si es cheat meal o no**.
- Agregado el DELETE para borrar un **UserAliment** (alimento del catálogo).

### Frontend

- Indicar que ciertas comidas puedan ser marcadas como cheat meal en **MealItem**.
- Creada la **función update del custom hook useMeals**, creado el **Thunk changeMealInDay** y creada la **función update en mealService (meals.js)**.
- Poder borrar alimentos del catálogo.
- Cambiado el nombre al archivo **AlimentCatalogSelector** como **AlimentCatalogSelectorForm**.
- Corregido el **select** de **AlimentCatalogSelectorForn**.
- Movida la llamada del custom hook de **useAliments** de **AlimentList** a **AlimentItemList**.
- Modificado los **selectors** para que redondeen a 2 decimales las calorías.
- Actualizado a **VITE 7.1.5**.

## Lo que se desea realizar:

### Backend

### Frontend

- Implementar loading, error en el custom hook **useWeeks**
- Modificar alimentos del catálago. Poder cambiar un valor nutricional en específico rápidamente.
- Al añadir un alimento a una comida, decidir si elegir un alimento del catálogo o añadir manualmente las calorías, el peso y el nombre.
- Componente que muestre como un índice con flechas en qué lugar nos encontramos.
- Si ya se ha iniciado sesión, al recargar, que compruebe que sigue habiendo usuario para poder iniciar, porque si borro el usuario en la base de datos pero tengo el token, puedo seguir creando cosas.
- Al añadir un alimento a una comida, que los alimentos disponibles de **AlimentCatalogSelectorForm** no aparezcan, los que ya se hayan añadido.

### Comentarios Finales

- **Manejo de errores** falta por implementar en la mayoría de la aplicación.
- **Validaciones de datos de entrada**.

### Problemas que tengo

- **Algunas funciones de mis services conocen en cierta parte la estructura de mi API**, debido a que uso .weekId, .dayId para construir la URL de la request. Lo estoy haciendo así porque si no me parece demasiado complicado entender qué es lo que se está pasando en la request a la API. En un futuro pienso cambiar eso.
- **Ahora mismo si recargo la página y estoy en una semana en específico, nunca me carga**, ya que en el componente para mostrar una semana en concreto, uso el useParams de la URL para buscar con el useSelector la semana por id, pero para que mi URL tenga el id de la semana, debo de hacer click en ella previamente, por eso al recargar la página, no tengo el weekId de useParams.
- **Uso de los custom hooks bastante lioso**, ya que en WeekSearch llamo a useWeeks desde el mismo desestructurando las funciones y las paso como props a los componentes que las necesiten. Lo hago así ya que este custom hook dentro tiene un useEffect que hace llamada a la API con un GET de todas las semanas con todos los datos, y si desestructurara las funciones en cada componente de manera individual sin tener que pasarle como props, harían este GET múltiples veces.<br><br>Posiblemente lo que haga es un nuevo custom hook que use al inicio de la app, al igual que el useInitializeAuth, pero solo hacer el get correspondiente y así quitarme el dolor de cabeza de pasar las funciones como props debido al useEffect que me limita a eso para que no ocurran muchas peticiones GET innecesarias.<br><br>En cambio, para el custom hook useDays: el equivalente de WeekSearch en cuanto a jerarquía / estructura / esquema de llamadas es el componente WeekItem, pero los componentes que usa, esos son los que llaman a este custom hook directamente con las funciones desestructuradas necesarias y no se pasan como props las funciones desde WeekItem.
- **Único controller para la API**, ya que ahora estoy haciendo que todo esté en el controller de weeks, ya que al final siempre todo lo que ocurre, ocurre dentro de una semana. Esto no es nada escalable.
- **Devolución de datos innecesaria**. Tengo que modificar todos los populate de mi API para que devuelva la información estrictamente necesaria en cualquier petición.
- **Refactorización completa del frontend** en el futuro, casi al finalizar la aplicación, para mejorar dependencias, peticiones a la API innecesarias, legibilidad del código, jerarquía de llamadas correcta, tener misma estructura en todo el frontend para que otra persona pueda leer el código y poder entenderlo.
- **Documentación final de la aplicación fullstack en inglés**
- **Borrar console.logs, poner comentarios claros, etc...**
